/*
 * date_proc.c - remote procedures; called by server stub.
 */
#include <rpc/rpc.h>	/* standard RPC include file */
#include <time.h>
#include <sys/types.h>
#include "date.h"	/* this file is generated by rpcgen */
#include <linux/kernel.h>
#include <sys/sysinfo.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define MAX_LEN 100
/*
 * Return the binary date and time.
 */
char ** date_1(long *option)
{
    struct tm *timeptr; /* Pointer to time structure      */
    time_t clock;       /* Clock value (in secs)          */
    static char *ptr;   /* Return string                  */
    static char err[] = "Invalid Response \0";
    static char s[MAX_LEN];

    clock = time(0);
    timeptr = localtime(&clock);

    switch(*option)
        {
        case 1: strftime(s,MAX_LEN,"%A, %B %d, %Y",timeptr);
                ptr=s;
                break;

        case 2: strftime(s,MAX_LEN,"%T",timeptr);
                ptr=s;
                break;

        case 3: strftime(s,MAX_LEN,"%A, %B %d, %Y - %T",timeptr);
                ptr=s;
                break;

        default: ptr=err;
                 break;
        }
    return(&ptr);
}

double *cpu_1(void)
{
  unsigned long long totalUptime2, totalUptimeLow2, totalSys2, totalIdle2;
  FILE* file = fopen("/proc/stat", "r");
  fscanf(file, "cpu %llu %llu %llu %llu", &totalUptime2, &totalUptimeLow2,
      &totalSys2, &totalIdle2);
  fclose(file);

  sleep(2);
  static double perc;
  unsigned long long totalUptime, totalUptimeLow, totalSys, totalIdle, total;

  file = fopen("/proc/stat", "r");
  fscanf(file, "cpu %llu %llu %llu %llu", &totalUptime, &totalUptimeLow,
      &totalSys, &totalIdle);
  fclose(file);

  if (totalUptime < totalUptime2 || totalUptimeLow < totalUptimeLow2 ||
      totalSys < totalSys2 || totalIdle < totalIdle2){
      perc = -1.0;
  }
  else{
      total = (totalUptime - totalUptime2) + (totalUptimeLow - totalUptimeLow2) +
          (totalSys - totalSys2);
      perc = total;
      total += (totalIdle - totalIdle2);
      perc = perc/total;
      perc *= 100;
  }

  return &perc;
}


double *memory_1(void)
{
  static double perct;
  struct sysinfo info;
  sysinfo(&info);
  long long totalMemory = info.totalram;
  long long memoryUsed = info.totalram - info.freeram;
  perct = (double)memoryUsed/(double)totalMemory*100;
  return &perct;

}

double *process_1(void)
{
  struct sysinfo sysInfo;
  sysinfo(&sysInfo);
  static double result;
  unsigned long  loadProcPermin = sysInfo.loads[0];
  result = (double)loadProcPermin;
  return &result;
}
